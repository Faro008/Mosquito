/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/assets/js/file.js":
/*!*******************************!*\
  !*** ./src/assets/js/file.js ***!
  \*******************************/
/***/ (function() {

eval("const aLinks = document.querySelectorAll('[data-link]');\r\n        const topOffset = document.querySelector('.container__GridHeader').offsetHeight;\r\n        let currentActiveElement = null; // Переменная для хранения текущего активного элемента\r\n        \r\n        aLinks.forEach(tabLinks);\r\n        \r\n        function tabLinks(item) {\r\n            item.addEventListener('click', function(event) {\r\n                event.preventDefault();\r\n        \r\n                // Находим целевой элемент, на который нужно скроллить\r\n                let tabId = item.getAttribute('data-link');\r\n                let currentLink = document.querySelector(tabId);\r\n        \r\n                // Вычисляем позицию целевого элемента с учетом смещения\r\n                let elementPosition = currentLink.getBoundingClientRect().top + window.pageYOffset;\r\n                const offsetPosition = elementPosition - topOffset;\r\n        \r\n                // Определяем начальную позицию для вычисления расстояния\r\n                let startPosition = currentActiveElement \r\n                    ? currentActiveElement.getBoundingClientRect().top + window.pageYOffset \r\n                    : window.pageYOffset;\r\n                // Используем подход из функции myMove для плавного скролла\r\n                let pos = startPosition;\r\n                let id = 0;\r\n                clearInterval(id);\r\n                id = setInterval(frame, 1);\r\n                function frame() {\r\n                    if (Math.abs(pos - offsetPosition) < 1) {\r\n                        clearInterval(id);\r\n                        currentActiveElement = currentLink; // Обновляем текущий активный элемент\r\n                    } else {\r\n                        // Плавное приближение к целевой позиции с эффектом ease-out\r\n                        //pos += (offsetPosition - pos)*.00195; // Двигаемся на 10% ближе к цели\r\n                       // pos++;\r\n                       pos += (offsetPosition > pos ? 1 : -1) * Math.min(Math.abs(offsetPosition - pos) * 0.1, 10);\r\n                        window.scrollTo(0, pos);\r\n                    }\r\n                }\r\n                \r\n                \r\n            });\r\n        }\r\n\r\n        //Задаем отступ от позиции fixed\r\n        const fixTop = document.getElementsByClassName('container__PresentHeaderGrid');\r\n        console.log(fixTop[0]);\r\n        fixTop[0].style.paddingTop = parseInt(topOffset) +  \"px\";\r\n\r\n        //Функция скролла мыши\r\n        let inertia = 0;\r\n        let scrollElement = document.scrollingElement || document.documentElement;\r\n        const scrollSpeed = 50;  // Задаем фиксированную скорость скролла\r\n        window.addEventListener('wheel', function(e,) {\r\n            e.preventDefault(); // Предотвращаем стандартное поведение\r\n            inertia += (e.deltaY > 0 ? scrollSpeed : -scrollSpeed);  // Скролл вверх или вниз\r\n            let scroll = function() {\r\n                if (Math.abs(inertia) > 0.1) {\r\n                    scrollElement.scrollTop +=(e.deltaY > 0 ? 1 : -1) *10;\r\n                    setTimeout(function() {inertia *=  0.8;}, 300);// Плавное затухание инерции\r\n                    requestAnimationFrame(scroll);\r\n                } else {\r\n                    inertia = 0; // Останавливаем инерцию\r\n                }\r\n            };;\r\n            scroll();\r\n        }, { passive: false });\n\n//# sourceURL=webpack://RomanFadeev/./src/assets/js/file.js?");

/***/ }),

/***/ "./src/assets/js/file2.js":
/*!********************************!*\
  !*** ./src/assets/js/file2.js ***!
  \********************************/
/***/ (function() {

eval("/*let inertia = 0;\r\nlet scrollElement = document.scrollingElement || document.documentElement;\r\nconst scrollSpeed = 50;  // Задаем фиксированную скорость скролла\r\n        window.addEventListener('wheel', function(e,) {\r\n            e.preventDefault(); // Предотвращаем стандартное поведение\r\n            inertia += (e.deltaY > 0 ? scrollSpeed : -scrollSpeed);  // Скролл вверх или вниз\r\n            let scroll = function() {\r\n                if (Math.abs(inertia) > 0.1) {\r\n                    scrollElement.scrollTop +=(e.deltaY > 0 ? 1 : -1) *10;\r\n                    setTimeout(function() {inertia *=  0.8;}, 300);\r\n                    //const myTimeout = setTimeout(myGreeting, 500);\r\n                    //function myGreeting() {\r\n                    //inertia *=  0.5; }// Плавное затухание инерции\r\n                    requestAnimationFrame(scroll);\r\n                } else {\r\n                    inertia = 0; // Останавливаем инерцию\r\n                }\r\n                \r\n            };;\r\n            scroll();\r\n        }, { passive: false });*/\r\n\r\n        \r\n/*        const aLinks = document.querySelectorAll('[data-link]');\r\n        const topOffset = document.querySelector('.container__GridHeader').offsetHeight;\r\n        let currentActiveElement = null; // Переменная для хранения текущего активного элемента\r\n        \r\n        aLinks.forEach(tabLinks);\r\n        \r\n        function tabLinks(item) {\r\n            item.addEventListener('click', function(event) {\r\n                event.preventDefault();\r\n        \r\n                // Находим целевой элемент, на который нужно скроллить\r\n                let tabId = item.getAttribute('data-link');\r\n                let currentLink = document.querySelector(tabId);\r\n        \r\n                // Вычисляем позицию целевого элемента с учетом смещения\r\n                let elementPosition = currentLink.getBoundingClientRect().top + window.pageYOffset;\r\n                const offsetPosition = elementPosition - topOffset;\r\n        \r\n                // Определяем начальную позицию для вычисления расстояния\r\n                let startPosition = currentActiveElement \r\n                    ? currentActiveElement.getBoundingClientRect().top + window.pageYOffset \r\n                    : window.pageYOffset;\r\n        \r\n                // Рассчитываем расстояние от текущего активного элемента до нового элемента\r\n                let distance = Math.abs(offsetPosition - startPosition);\r\n        \r\n                // Устанавливаем разное время скролла на основе расстояния\r\n                let scrollDuration;\r\n                if (distance < 1000) {\r\n                    scrollDuration = 5;\r\n                } else if (distance < 2000) {\r\n                    scrollDuration = 6;\r\n                } else if (distance < 4000) {\r\n                    scrollDuration = 7;\r\n                } else {\r\n                    scrollDuration = 18;\r\n                }\r\n        \r\n                console.log(\"Расстояние:\", distance);\r\n                console.log(\"Текущий офсет:\", offsetPosition);\r\n                console.log(\"Начальная позиция:\", startPosition);\r\n        \r\n                // Используем подход из функции myMove для плавного скролла\r\n                let pos = startPosition;\r\n                let id = 0;\r\n                clearInterval(id);\r\n                id = setInterval(frame, 1);\r\n                console.log(\"Time:\", scrollDuration);\r\n                console.log(\"Условие:\", Math.abs(pos - offsetPosition));\r\n                function frame() {\r\n                    if (Math.abs(pos - offsetPosition) < 1) {\r\n                        clearInterval(id);\r\n                        currentActiveElement = currentLink; // Обновляем текущий активный элемент\r\n                        console.log(\"Остановка функции\");\r\n                    } else {\r\n                        // Плавное приближение к целевой позиции с эффектом ease-out\r\n                        //pos += (offsetPosition - pos)*.00195; // Двигаемся на 10% ближе к цели\r\n                       // pos++;\r\n                       pos += (offsetPosition > pos ? 1 : -1) * Math.min(Math.abs(offsetPosition - pos) * 0.1, 10);\r\n                        console.log('Позиция рили:', pos);\r\n                        window.scrollTo(0, pos);\r\n                    }\r\n                }\r\n                \r\n                \r\n            });\r\n        }\r\n        */\r\n\r\n\r\n\n\n//# sourceURL=webpack://RomanFadeev/./src/assets/js/file2.js?");

/***/ }),

/***/ "./src/assets/js/scroll.js":
/*!*********************************!*\
  !*** ./src/assets/js/scroll.js ***!
  \*********************************/
/***/ (function() {

eval("/*const aLinks = document.querySelectorAll('[data-link]');\r\nconst topOffset = document.querySelector('.container__GridHeader').offsetHeight;\r\naLinks.forEach (tabLinks);\r\nfunction tabLinks(item) {\r\n    item.addEventListener('click',function(event) {\r\n    event.preventDefault();\r\n    let thisItem = item;\r\n    let tabId = thisItem.getAttribute('data-link');\r\n    let currentLink = document.querySelector(tabId);\r\n    let elementPosition = currentLink.getBoundingClientRect().top;\r\n    const offsetPosition = elementPosition - topOffset;\r\n        window.scrollBy({\r\n            top: offsetPosition,\r\n            behavior: 'smooth'\r\n        });\r\n    });\r\n}\r\n//Задаем отступ от позиции fixed\r\nconst fixTop = document.getElementsByClassName('container__PresentHeaderGrid');\r\nconsole.log(fixTop[0]);\r\nfixTop[0].style.paddingTop = parseInt(topOffset) +  \"px\";\r\n\r\n/*\r\n//Функция скролла с замедлением\r\nconst aLinks = document.querySelectorAll('[data-link]');\r\n        const topOffset = document.querySelector('.container__GridHeader').offsetHeight;\r\n        let currentActiveElement = null; // Переменная для хранения текущего активного элемента\r\n        \r\n        aLinks.forEach(tabLinks);\r\n        \r\n        function tabLinks(item) {\r\n            item.addEventListener('click', function(event) {\r\n                event.preventDefault();\r\n        \r\n                // Находим целевой элемент, на который нужно скроллить\r\n                let tabId = item.getAttribute('data-link');\r\n                let currentLink = document.querySelector(tabId);\r\n        \r\n                // Вычисляем позицию целевого элемента с учетом смещения\r\n                let elementPosition = currentLink.getBoundingClientRect().top + window.pageYOffset;\r\n                const offsetPosition = elementPosition - topOffset;\r\n        \r\n                // Определяем начальную позицию для вычисления расстояния\r\n                let startPosition = currentActiveElement \r\n                    ? currentActiveElement.getBoundingClientRect().top + window.pageYOffset \r\n                    : window.pageYOffset;\r\n        \r\n                // Рассчитываем расстояние от текущего активного элемента до нового элемента\r\n                let distance = Math.abs(offsetPosition - startPosition);\r\n        \r\n                // Устанавливаем разное время скролла на основе расстояния\r\n                let scrollDuration;\r\n                if (distance < 1000) {\r\n                    scrollDuration = 5;\r\n                } else if (distance < 2000) {\r\n                    scrollDuration = 6;\r\n                } else if (distance < 4000) {\r\n                    scrollDuration = 7;\r\n                } else {\r\n                    scrollDuration = 18;\r\n                }\r\n        \r\n                console.log(\"Расстояние:\", distance);\r\n                console.log(\"Текущий офсет:\", offsetPosition);\r\n                console.log(\"Начальная позиция:\", startPosition);\r\n        \r\n                // Используем подход из функции myMove для плавного скролла\r\n                let pos = startPosition;\r\n                let id = 0;\r\n                clearInterval(id);\r\n                id = setInterval(frame, 1);\r\n                console.log(\"Time:\", scrollDuration);\r\n                console.log(\"Условие:\", Math.abs(pos - offsetPosition));\r\n                function frame() {\r\n                    if (Math.abs(pos - offsetPosition) < 1) {\r\n                        clearInterval(id);\r\n                        currentActiveElement = currentLink; // Обновляем текущий активный элемент\r\n                        console.log(\"Остановка функции\");\r\n                    } else {\r\n                        // Плавное приближение к целевой позиции с эффектом ease-out\r\n                        //pos += (offsetPosition - pos)*.00195; // Двигаемся на 10% ближе к цели\r\n                       // pos++;\r\n                       pos += (offsetPosition > pos ? 1 : -1) * Math.min(Math.abs(offsetPosition - pos) * 0.1, 10);\r\n                        console.log('Позиция рили:', pos);\r\n                        window.scrollTo(0, pos);\r\n                    }\r\n                }\r\n                \r\n                \r\n            });\r\n        }\r\n\r\n        //Функция скролла колесика мыши\r\n        let inertia = 0;\r\nlet scrollElement = document.scrollingElement || document.documentElement;\r\nconst scrollSpeed = 50;  // Задаем фиксированную скорость скролла\r\n        window.addEventListener('wheel', function(e,) {\r\n            e.preventDefault(); // Предотвращаем стандартное поведение\r\n            inertia += (e.deltaY > 0 ? scrollSpeed : -scrollSpeed);  // Скролл вверх или вниз\r\n            let scroll = function() {\r\n                if (Math.abs(inertia) > 0.1) {\r\n                    scrollElement.scrollTop +=(e.deltaY > 0 ? 1 : -1) *10;\r\n                    setTimeout(function() {inertia *=  0.8;}, 300);\r\n                    //const myTimeout = setTimeout(myGreeting, 500);\r\n                    //function myGreeting() {\r\n                    //inertia *=  0.5; }// Плавное затухание инерции\r\n                    requestAnimationFrame(scroll);\r\n                } else {\r\n                    inertia = 0; // Останавливаем инерцию\r\n                }\r\n                \r\n            };;\r\n            scroll();\r\n        }, { passive: false });\r\n\r\n/*console.log(aLinks);\r\nconsole.log(aLinks.length);\r\n    console.log(thisItem);\r\n    console.log(tabId);\r\n    console.log(currentLink);\r\n    console.log(elementPosition);\r\n    console.log(offsetPosition);\r\n    */\r\n\n\n//# sourceURL=webpack://RomanFadeev/./src/assets/js/scroll.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	__webpack_modules__["./src/assets/js/file.js"]();
/******/ 	__webpack_modules__["./src/assets/js/file2.js"]();
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/assets/js/scroll.js"]();
/******/ 	
/******/ })()
;